"""
Clair Obscur CTF Challenge - Smart Solution

Key Insight:
- We control p, G, and O
- The challenge computes P = k*G where k is the flag
- We can choose G and O such that the group has SMALL ORDER
- If we can make the group order small, we can use Pohlig-Hellman or brute force

Alternative approach:
- Choose G = O (identity element if possible)
- Or choose points that generate a small cyclic group
- The scalar multiplication becomes trivial

Even better:
- We can choose parameters where G has small order
- Even with 256-bit p, if G generates a small subgroup, discrete log is easy!
"""

from sage.all import *
from Crypto.Util.number import long_to_bytes, bytes_to_long

# We need to find a 256-bit prime and points such that G has small order

def main():
    print("="*70)
    print("CLAIR OBSCUR - Smart Attack")
    print("="*70)
    
    # The trick: we need G to generate a group of small order
    # Even with large p, if the curve/group has special structure, we can win
    
    # Let's try finding a prime and points where we can compute order
    print("\nLooking for a 256-bit prime and suitable points...")
    
    # Start with a 256-bit prime
    p = next_prime(2**255)
    print(f"Prime p ({p.bit_length()} bits): {p}")
    
    Fp = GF(p)
    
    # Find points on curve: a*b^2 + b*c^2 + c*d^2 + d*a^2 = 0
    # Let's try specific simple points
    
    # Try point [1, 0, 0, 0]: 1*0 + 0*0 + 0*0 + 0*1 = 0 ✓
    # Try point [0, 1, 0, 0]: 0*1 + 1*0 + 0*0 + 0*0 = 0 ✓
    # Try point [0, 0, 1, 0]: 0*0 + 0*1 + 1*0 + 0*0 = 0 ✓
    
    def check_point(p, pt):
        a, b, c, d = pt
        Fp = GF(p)
        a, b, c, d = Fp(a), Fp(b), Fp(c), Fp(d)
        result = a * b**2 + b * c**2 + c * d**2 + d * a**2
        return result == 0
    
    # Test some simple points
    candidates = [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0],
        [0, 0, 0, 1],
        [1, 1, 0, 0],
        [1, 0, 1, 0],
    ]
    
    valid_points = []
    for pt in candidates:
        if check_point(p, pt):
            valid_points.append(pt)
            print(f"Valid point: {pt}")
    
    if len(valid_points) >= 2:
        G = valid_points[0]
        O = valid_points[1]
        
        print(f"\nChosen:")
        print(f"G = {G}")
        print(f"O = {O}")
        
        print("\n" + "="*70)
        print("INPUTS FOR THE CHALLENGE:")
        print("="*70)
        print(p)
        print(','.join(map(str, G)))
        print(','.join(map(str, O)))
        print("="*70)
        
        return p, G, O
    else:
        # Find points computationally
        print("\nSearching for valid points...")
        points = []
        for a in range(min(50, p)):
            for b in range(min(50, p)):
                for c in range(min(50, p)):
                    if len(points) >= 5:
                        break
                    x = Fp['x'].gen()
                    eq = Fp(a) * Fp(b)**2 + Fp(b) * Fp(c)**2 + Fp(c) * x**2 + x * Fp(a)**2
                    roots = eq.roots()
                    for d, _ in roots:
                        pt = [int(a), int(b), int(c), int(d)]
                        points.append(pt)
                        print(f"Found point: {pt}")
                        if len(points) >= 5:
                            break
                if len(points) >= 5:
                    break
            if len(points) >= 5:
                break
        
        G = points[0]
        O = points[1]
        
        print(f"\nChosen:")
        print(f"G = {G}")
        print(f"O = {O}")
        
        print("\n" + "="*70)
        print("INPUTS FOR THE CHALLENGE:")
        print("="*70)
        print(p)
        print(','.join(map(str, G)))
        print(','.join(map(str, O)))
        print("="*70)
        
        return p, G, O


if __name__ == "__main__":
    # Run the attack setup
    main()
    
    print("\n" + "="*70)
    print("AFTER GETTING P FROM SERVER:")
    print("="*70)
    print("""
# Paste the server output here:
# P = [a, b, c, d]

# Then run discrete log solver:
# This might take time depending on the order of G

from sage.all import *
from Crypto.Util.number import long_to_bytes

# [Copy CO class and run solver]
# k = solve_discrete_log(curve, P)
# flag = 'W1{' + long_to_bytes(k).decode() + '}'
# print(f"Flag: {flag}")
    """)
