import re, sys, struct, socket, os
from Crypto.Cipher import AES

HOST =  "crypto1.cscv.vn"
PORT = 1337

R = 0xe1000000000000000000000000000000

def b2i (b: bytes) -> int:
    return int.from_bytes(b, "big")

def i2b (x: int) -> bytes:
    return x.to_bytes(16, "big")

def gf_mul(x: int, y: int) -> int:
    z = 0; v = x; u = y
    for _ in range(128):
        if u & 1: z ^= v
        u >>= 1
        v = ((v >> 1) ^ R) if (v & 1) else (v >> 1)
    return z


def gf_pow(h: int, n: int) -> int:
    res = 1; base = h
    while n:
        if n & 1: res = gf_mul(res, base)
        base = gf_mul(base, base); n >>= 1
    return res
def gf_inv(x: int) -> int:
    return gf_pow(x, (1 << 128) - 2)

def ghash_blocks(H: int, blocks, total_len_bytes: int) -> int:
    y = 0
    for b in blocks:
        y = gf_mul(y ^ b, H)
    L = ((0) << 64) | (total_len_bytes * 8)
    y = gf_mul((y ^ L), H)
    return y
def inc32(j: bytes) -> bytes:
    prefix, ctr = j[:-4], j[-4:]
    c = (int.from_bytes(ctr, "big") + 1) & 0xffffffff
    return prefix + c.to_bytes(4, "big")

def aes_ecb_enc(k: bytes, blk: bytes) -> bytes:
    return AES.new(k, AES.MODE_ECB).encrypt(blk)
def get_keystream_blocks(k: bytes, nonce: bytes, nblocks: int):
    j0 = nonce + b"\x00\x00\x00\x01"
    ctr = inc32(j0)
    out = []
    for _ in range(nblocks):
        out.append(aes_ecb_enc(k, ctr))
        ctr = inc32(ctr)
    return out, j0
def xor_bytes(a: bytes, b: bytes) -> bytes:
    return bytes(x ^ y for x, y in zip(a, b))

def build_dual_valid_ciphertext(kS: bytes, kF: bytes, nonce: bytes) -> bytes:
    ks_S, j0_S = get_keystream_blocks(kS, nonce, 3)
    ks_F, j0_F = get_keystream_blocks(kF, nonce, 3)

    Hs = b2i(aes_ecb_enc(kS, b"\x00"*16))
    Hf = b2i(aes_ecb_enc(kF, b"\x00"*16))
    E_S_j0 = b2i(aes_ecb_enc(kS, j0_S))
    E_F_j0 = b2i(aes_ecb_enc(kF, j0_F))
    deltaE = E_S_j0 ^ E_F_j0

    P2_b0 = b"admin = True" + b" "*(16 - len(b"admin = True"))
    P1_b1 = b"admin = False" + b" "*(16 - len(b"admin = False"))

    C0 = b2i(xor_bytes(P2_b0, ks_F[0]))
    C1 = b2i(xor_bytes(P1_b1, ks_S[1]))

    Hs2, Hf2 = gf_mul(Hs,Hs), gf_mul(Hf,Hf)
    Hs3, Hf3 = gf_mul(Hs2,Hs), gf_mul(Hf2,Hf)
    Hs4, Hf4 = gf_mul(Hs3,Hs), gf_mul(Hf3,Hf)
    dH1, dH2, dH3, dH4 = Hs ^ Hf, Hs2 ^ Hf2, Hs3 ^ Hf3, Hs4 ^ Hf4
    L = 16*3
    rhs = deltaE ^ gf_mul(((0<<64)|(L*8)), dH1) ^ gf_mul(C0, dH4) ^ gf_mul(C1, dH3)
    C2 = gf_mul(rhs, gf_inv(dH2))

    GH_S = ghash_blocks(Hs, [C0, C1, C2], 16*3)
    tag = i2b(E_S_j0 ^ GH_S)
    ct = i2b(C0) + i2b(C1) + i2b(C2)

    P1 = xor_bytes(ct[:16], ks_S[0]) + xor_bytes(ct[16:32], ks_S[1]) + xor_bytes(ct[32:], ks_S[2])
    P2 = xor_bytes(ct[:16], ks_F[0]) + xor_bytes(ct[16:32], ks_F[1]) + xor_bytes(ct[32:], ks_F[2])
    assert b"admin = True" not in P1
    assert b"admin = False" in P1[16:32]
    assert b"admin = True" in P2[:16]
    assert b"admin = False" not in P2

    return nonce + ct + tag
def recv_until(sock, token: bytes) -> bytes:
    data = b""
    while token not in data:
        chunk = sock.recv(4096)
        if not chunk: break
        data += chunk
    return data
def main():
    s = socket.create_connection((HOST, PORT))
    recv_until(s, b"Enter your choice: ")

    s.sendall(b"2\n")
    out = recv_until(s, b"Enter your choice: ")
    m = re.search(rb"current FlagKeeper key:\s*([0-9a-fA-F]{32})", out)
    kF = bytes.fromhex(m.group(1).decode())

    s.sendall(b"1\n")
    recv_until(s, b"Enter your choice: ")

    s.sendall(b"1\n")
    out = recv_until(s, b"Enter your choice: ")
    m = re.search(rb"current Server key:\s*([0-9a-fA-F]{32})", out)
    kS = bytes.fromhex(m.group(1).decode())

    nonce = os.urandom(12)
    enc = build_dual_valid_ciphertext(kS, kF, nonce)

    s.sendall(b"3\n")
    recv_until(s, b"in hex): ")
    s.sendall(enc.hex().encode() + b"\n")
    out = recv_until(s, b"Enter your choice: ")
    sig = re.search(rb"Signature \(in hex\):\s*([0-9a-fA-F]+)", out).group(1).decode()

    s.sendall(b"4\n")
    recv_until(s, b"in hex): ")
    s.sendall(enc.hex().encode() + b"\n")
    recv_until(s, b"in hex): ")
    s.sendall(sig.encode() + b"\n")
    print(s.recv(4096).decode(errors="ignore"))

if __name__ == "__main__":
    main()
    recv_until(s, b"in hex): ")
    s.sendall(sig.encode() + b"\n")
    print(s.recv(4096).decode(errors="ignore"))

if __name__ == "__main__":
    main()